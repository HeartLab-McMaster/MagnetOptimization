#!/usr/bin/env python
# coding: utf-8

# ## Magnet optimization

# In[1]:


from scipy.spatial.transform import Rotation as R
import numpy as np
import cvxpy as cp


# In[2]:


Br = 1.31 # (T) Residual flux density for N42
mu_0 = 4 * np.pi * 10**-7 # (H/m) Permeability of free space
l = 25e-3 # (m) Length of cube magnet
Volume = l ** 3 # (m^3)
moment = Br * Volume / mu_0 # (A m^2)
J = Br / mu_0 # (A/m)
print(moment)


# In[3]:


target = np.array([0, 0, 0.4]) # target position is at 40 cm above the origin
workspace_length = 0.2 # workspace is a cube of 20 cm side length
mt = np.array([moment, 0, 0])


# In[4]:


# return the magnetic field generated by a magnet at position p and orientation r
def generate_random_pose() -> tuple[np.ndarray, np.ndarray]:
    # generate a random pose
    r = R.random()
    p = np.random.rand(3) * workspace_length
    return p, r.as_matrix()


# In[5]:


def B(r_i: np.ndarray, dm_i: np.ndarray):
  r_i_hat = r_i / np.linalg.norm(r_i)
  return mu_0 * moment / (4 * np.pi * np.linalg.norm(r_i) ** 3) * np.dot((3 * r_i_hat*np.transpose(r_i_hat) - np.eye(3)), dm_i)

def F(r_i: np.ndarray, dm_i: np.ndarray):
  r_i_hat = r_i / np.linalg.norm(r_i)
  return 3 * mu_0 * moment / (4 * np.pi * np.linalg.norm(r_i) ** 4) \
    * np.dot(
      np.dot(dm_i, r_i_hat.transpose()) + 
      np.dot(r_i_hat, dm_i.transpose()) - 
      np.dot(np.dot(r_i_hat.transpose(), dm_i), (5 * r_i_hat*np.transpose(r_i_hat) - np.eye(3)))
      , mt)

def Jb(r_i: np.ndarray, dm_i: np.ndarray):
  r_i_hat = r_i / np.linalg.norm(r_i)
  return mu_0 * moment / (4 * np.pi * np.linalg.norm(r_i) ** 3) * np.dot((3 * r_i_hat*np.transpose(r_i_hat) - np.eye(3)), dm_i)

def Jf(r_i: np.array, dm_i: np.ndarray):
  r_i_hat = r_i / np.linalg.norm(r_i)
  return 3 * mu_0 * moment / (4 * np.pi * np.linalg.norm(r_i) ** 4) \
    * np.dot(
      np.dot(dm_i, r_i_hat.transpose()) + 
      np.dot(r_i_hat, dm_i.transpose()) - 
      np.dot(np.dot(r_i_hat.transpose(), dm_i), (5 * r_i_hat*np.transpose(r_i_hat) - np.eye(3)))
      ,mt)


# In[6]:


m = 100
K = 6 # Selection budget
d = 4
n = d ** K


# In[7]:


# Generating all combinations of angles
angles = np.array(np.meshgrid(*[np.linspace(0, np.pi, d) for i in range(K)])).T.reshape(-1, K)


# In[8]:


# S is an array of tuples, each tuple contains a position and a rotation matrix
S = [generate_random_pose() for i in range(m)]


# In[9]:


# Initizaling A
A = np.zeros((n, K, m, 6, 6))

for t, theta in enumerate(angles):
  for i in range(K):
    for j, (p, r) in enumerate(S):
      magnetization = r.dot([np.cos(theta[i]), np.sin(theta[i]), 0])
      J = np.concatenate([Jb(p, magnetization), Jf(p, magnetization)])
      A[t, i, j, :, :] = np.outer(J, J)
    


# In[10]:


def A_operator(X, t):
  return sum([X[i][j] * A[t, i, j] for i in range(K) for j in range(m)])

def f_operator(X):
  f = np.concatenate([Jb(p, magnetization), Jf(p, magnetization)])


# In[11]:


X = cp.Variable(shape=(K, m))
t = cp.Variable(1)

obj = cp.Maximize(t)
cons1 = X >= 0.0
cons2 = X <= 1.0
cons4 = cp.sum(X) == K
cons5 = cp.sum(X, axis=1) == 1.0
cons6 = cp.sum(X, axis=0) <= 1.0
constraints = [cons1, cons2, cons4, cons5, cons6]
for i in range(n):
  constraints.append(t <= cp.atoms.lambda_min(A_operator(X, i)))
prob = cp.Problem(obj, constraints)


# In[12]:


prob.solve(verbose=True)

print("Status: ", prob.status)
print("Solution x = ", X.value)
print("Solution t = ", X.value)


# In[ ]:


# In[18]:


import pickle, random
dp = dict(S=S, X=X, t=t)

with open("checkpoint4.pkl", "wb") as cp_file:
    pickle.dump(dp, cp_file)